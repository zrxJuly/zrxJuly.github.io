<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何坚持完成自己的目标和计划？]]></title>
    <url>%2F2020-02%2Fhow-to-accomplish-your-plan%2F</url>
    <content type="text"><![CDATA[自己的航道必须自己掌舵，即便风雨交加，也要坚持不懈。 认清自己，摆脱问题你是否一直坚持着一种仪式感：每次新年前后都要为自己新的一年制定一系列的目标计划，踌躇满志。 你是否不满足于现状，抱怨所处的环境或身边的人在阻碍你的进步，想要努力改变，提升自己。于是你辞掉让你头疼的工作，或者搬去一个新的城市，期待着一个新的环境能够让你摆脱当下的不快乐，重新开始新的生活。 但通常情况是： 当你年底进行复盘的时候，看着自己年初制定的目标计划，实现的却没有几个； 你做出了巨大改变，处在一个全新的环境中，但是依旧面临和以前一样的问题，纵然身处的环境变了，但是你的行为和生活习惯却没变。 那是因为你根本没有摆脱原来的自己。 或许对你来说，新的时间节点、新的环境、新的工作意味着新的开始，但若你无法逃离原来的缺点、坏习惯以及处理事情的方式，不管你制定什么目标计划，不管你去到哪里，这些问题会一直跟随着你，除非你自己试着去克服它们，改变它们。 如果你自律性很强，从没遇到过上述类似问题，能够完美的实现自己预定的目标，这么优秀的你，我真的非常羡慕、佩服。但假如你也和我一样，没有很强的自律性，没有很好的工作、学习、生活习惯，完美的计划实现起来往往不尽如人意，那你就需要认清自己，摆脱现有的问题。如果不从自身情况出发，找出问题所在，你的目标计划往往很难完美实现。 Get Start Now！没错，就是从现在开始着手去做。 比如，如果现在你身旁有一本书，不妨现在就拿来读一读。我知道，一开始就让你专心会很难，或许会有些痛苦，因为你不习惯，但是请你静下心来坚持读二十分钟，你会发现，阅读带给你的不仅仅是书中的知识，更是你能够坚持做一件事产生的自信。因为你内心渴望优秀，所以也请你坚持下去。 有时往往你的目标并不难实现，但是每次当你开始为你的目标而努力的时候，内心仿佛总有一个声音在告诉你： 不着急，还有的是时间呢。算了，今天太晚了，等明天再做吧！这件事太难了！等抽空专门再做吧。…… 就这样，由于你的“完美借口”，将事情一拖再拖，你的完美计划最终成功泡汤。于是，你又重新开始制定新的计划，然后像上面那样循环往复…… 因此，积极性的心理暗示很重要。尤其当你身体懒惰时，经常给自己积极性的心理暗示，让自己内心深处督促自己。 所以，从现在开始去做吧，远离那些对你的成长毫无帮助的事物，哪怕每天十分钟，只要用心坚持，定能有所收获。 准确合理的制定并执行计划制定一个时长为一周的目标，而不是一个月甚至一年的目标。 如果你还没有养成很好的习惯，如果你还不能每天坚持去做自己计划的事情，那么请不要把你的计划周期制定的很长，计划不要过于复杂，目标不要定的太高，要简单明确，切实可行。 以周、日为单位，尽量不要以年。比如： 把“计划今年看完10本书”改成“计划每天看完10页书” “今天要看完10页书”； 把“计划每天记20个单词”改成“今天要记20个单词”。 将时间长远的目标，分割确定为每周、每天、甚至今天要完成的小目标，让你的每一天都充实起来。执行计划的过程，也是养成你的良好习惯的过程，要坚持。如果你的短期计划成功了的话，那么接着进行下一阶段目标。如果没有成功，请把你的标准降低一点儿吧。so，你的计划制定的合理吗？ 记录成长，总结失败定期复盘，记录你所做的事情，总结得失。 如果可以的话，每天进行复盘，写写日记，记下你这一天有意思的事情，你的收获，你犯过的错误，时刻反省自己，正所谓“吾日三省吾身”。若时间紧张，每周或者每月也应该要复盘一次，要坚持。 正如孔子对其弟子所言：“不迁怒，不贰过”。既不会把愤怒发泄在别人身上，自己也不会犯同样的错误。 共勉。 写在最后没有任何能够让你成长的事情是容易的。分享一段尼克·胡哲的名言： “当你打算放弃梦想时，告诉自己再多撑一天、一个星期、一个月，再多撑一年吧。你会发现，拒绝退场的结果令人惊讶。” 既然2020不能重启，那就努力改变、提升自己吧。 “愿你的身后总有力量，愿你成为自己的太阳”。 这一年，愿你努力成长，做你自己的英雄。 - End - 这世界独一无二的你 愿有前程可奔赴，亦有岁月可回首 微信扫描二维码，关注我的公众号]]></content>
      <categories>
        <category>媛思</category>
      </categories>
      <tags>
        <tag>媛思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Centos7搭建测试环境]]></title>
    <url>%2F2019-08%2Flinux-environment-build%2F</url>
    <content type="text"><![CDATA[摘要 环境安装工具准备 JDK安装 tomcat安装 MySQL安装 一、环境安装工具准备 Linux系统：centos7 安装工具 JDK8安装包：jdk-8u131-linux-x64.rpm Tomcat8.5安装包：apache-tomcat-8.5.41.tar.gz MySQL5.6安装包：mysql-5.6.45-linux-glibc2.12-x86_64.tar.gz 工具下载可从官网下载。已把安装工具存于百度网盘：&emsp;&emsp;链接：https://pan.baidu.com/s/1ts1vRhtzKeMmP9VlnDi4gg&emsp;&emsp;提取码：2nom 工具上传如何将安装包上传到Linux服务器上？两个工具：WinSCP和SecureCRT（of course,其他的也可以滴) 二、JDK安装-JDK安装包存放位置&emsp;&emsp;建议将安装包存放到 /usr/local/ 目录下。[不要放在 /home 路径下，容易涉及到不同用户的访问权限]。&emsp;&emsp;我的存放到了 /usr/local/tools/ 下，安装工具都放到了这里。 -执行安装命令进入到 /usr/local/tools/ 下，执行： 1rpm -ivh jdk-8u131-linux-x64.rpm -检查是否安装成功&emsp;&emsp;安装完成后，输入 java -version 检查是否安装成功。出现java的版本信息，即安装成功： -配置环境变量查看JDK安装路径配置环境变量前，我们需要知道JDK的安装路径。如下图，依次按照红框内命令执行： 图上最后划红线的即安装路径。 配置环境变量编辑 /etc/profile文件： 1vim /etc/profile [输入i，进行编辑]复制如下内容，粘贴到文件末尾： 123export JAVA_HOME=/usr/java/jdk1.8.0_131/export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar [Esc退出编辑，:wq 保存退出]。 重新加载环境变量使配置生效输入： 1source /etc/profile 三、tomcat安装-解压Tomcat安装包进入到 /usr/local/tools/ 下，执行命令解压Tomcat安装包： 1tar -zxvf apache-tomcat-8.5.41.tar.gz -移动并重新命名文件夹（非必须步骤）我这里将解压后的Tomcat移动到了 /usr/local 下，并重新命名文件夹： 1mv apache-tomcat-8.5.41 /usr/local/tomcat8-80 -修改Tomcat端口号（非必须步骤）进入conf，编辑server.xml文件，可修改端口号. -Tomcat内多余文件(夹)的删除（非必须步骤）在webapps下，除了ROOT及其目录下的文件(测试启动是否成功，访问用)，其他都可删除，可删除目录如下红框内： -启动Tomcat到bin目录下，输入./startup.sh ，启动Tomcat，浏览器输入 ip:端口号 访问（确保服务器已开启端口访问权限），若成功访问，则配置成功。 - 一个Linux服务器内启动多个Tomcat多个Tomcat安装在同一台操作系统上，需修改Tomcat的配置文件server.xml的三个端口1. 8005端口 1&lt;Server port="8005" shutdown="SHUTDOWN"&gt; 作用：关闭Tomcat通信接口。该端口负责监听关闭Tomcat的请求。这里我改成了8006 2. 8080端口 1&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/&gt; 作用：建立http连接，例如浏览器访问。这里我改成了8081 3. 8009端口 1&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443"/&gt; 作用：与其他http服务器通信接口，用于http服务器集合这里我改成了8010 以上三个端口，各个Tomcat只要不冲突即可。 四、MySQL安装- 检查是否安装过mysql查询： 1rpm -qa|grep -i mysql 删除遗留MySQL： 1rpm -e 文件名 --nodeps - 解压进入MySQL安装包所在目录，执行解压命令： 1tar -zxvf mysql-5.6.45-linux-glibc2.12-x86_64.tar.gz - 重命名将解压后的MySQL（移动）重命名为mysql，/usr/local/下： 1mv mysql-5.6.45-linux-glibc2.12-x86_64 /usr/local/mysql - 添加用户组和用户命令groups mysql查看用户组，若已添加，会提示已存在，可不用再重复添加。 添加用户组：1groupadd mysql 添加用户：1useradd -r -g mysql mysql - 修改配置文件进入到/usr/local/mysql目录下： 复制配置文件 1cp support-files/my-default.cnf /etc/my.cnf 配置my.cnf 1vim /etc/my.cnf 文件末尾添加以下配置信息(也可将原文件内容清空，把以下内容复制，注意basedir和datadir要替换成自己mysql的目录位置)： 1234567891011121314[mysql] default-character-set=utf8[mysqld] #skip-grant-tablesskip-name-resolve port = 3306 # 解压后的mysql的位置basedir=/usr/local/mysqldatadir=/usr/local/mysql/data max_connections=200 character-set-server=utf8 default-storage-engine=INNODBlower_case_table_names=1max_allowed_packet=16M - 安装进入到/usr/local/mysql目录下，执行安装命令： 1./scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql/ 若执行命令时出现如下报错信息(一般是相应库没有安装，我安装时遇到以下两个错误，从网上查一下解决办法，安装相应库即可)： please install the following Perl modules before executing ./scripts/mysql_install_db:解决方法：安装autoconf库： 1yum -y install autoconf ...error while loading shared libraries: libaio.so.1...解决方法：安装libaio库： 1yum -y install libaio* - 修改目录权限进入到mysql下修改当前目录拥有者为root用户： 1chown -R root:root ./ 修改data目录拥有者为mysql用户： 1chown -R mysql:mysql data - 启动启动方法一1service mysqld start 若启动时，出现如下错误：Failed to start mysqld.service: Unit not found. 问题原因： &emsp;&emsp;由于/etc/init.d/ 不存在mysqld命令。但是有的安装完成后存在，是因为安装包中有相应的命令将mysql.server文件copy到/etc/init.d/下面了。 解决方法1： 进入到mysql目录下，执行如下命令： 1cp ./support-files/mysql.server /etc/init.d/mysqld 再执行以下任何命令，都可成功： 1234service mysqld status # 查看mysql当前启动状态service mysqld stop # 停止mysql服务service mysqld start # 启动mysql服务service mysqld restart # 重启mysql服务 解决方法2 【网上的另一种解决方法】第1步 安装mariadb-server 1yum install -y mariadb-server 第2步 启动服务 1systemctl start mariadb.service 第3步 添加到开启启动 1systemctl enable mariadb.service 以前版本的CentOS都是使用MySQL作为数据库的，而从CentOS 7开始启用了MariaDB。相关参考：CentOS 7为什么放弃了MySQL，而改使用MariaDB？ 启动方法二该启动方法，不存在方法一的问题，mysql目录下执行命令： 1./support-files/mysql.server start 如何关闭mysql服务？将上面的命令start改为stop即可，如下： 1./support-files/mysql.server stop - 修改密码登录数据库以root账号登录mysql，默认是没有密码的： 1mysql -h127.0.0.1 -P3306 -uroot -p 提示输入密码的时候，直接回车即可。 但当用命令mysql -uroot -p登录时，报错： 问题描述：Can&#39;t connect to local MySQL server through socket &#39;/var/lib/mysql/mysql.sock&#39; 问题原因： 目标文件mysql.lock找不到。mysql.sock可能会根据实际安装方式的不同，存放在不同的目录下，可能是/var/lib/mysql.sock或/tmp/mysql.sock或其他目录下，我的是在/tmp/mysql.sock下： 解决方法： 创建软连接：ln -s 源文件 目标文件 1ln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock 然后重新用mysql -uroot -p，登录成功！参考链接：https://blog.csdn.net/JustinQin/article/details/79209073 密码修改root账号登录后，查看mysql账号信息： 1SELECT user,host,password FROM mysql.user; 上图我们可以看到，所有账号都是没有密码的。修改root登录密码为root： 1update mysql.user set password=password(&apos;root&apos;) where user=&apos;root&apos;; 如果想设置不同host登录密码不同，可在条件上加上 and host=&#39;&#39;; 1update mysql.user set password=password(&apos;root&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;; 修改完后，记得刷新权限： 1flush privileges; - 设置远程主机登录若允许root用户只能在特定ip进行远程登录，并具有所有库的操作权限，则需要指定ip： 1GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;特定ip&apos; IDENTIFIED BY &apos;你的登录密码&apos; WITH GRANT OPTION; 允许root用户在任何地方进行登录，并具有所有库的操作权限： 1GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;你的登录密码&apos; WITH GRANT OPTION; 修改完后，记得刷新权限： 1flush privileges; 总结&emsp;&emsp;以上，Linux搭建测试环境步骤就告一段落啦在安装MySQL的时候，遇到了很多问题，不过遇到问题就解决，并及时记录下来，还是学到了很多东西的要努力学技术，毕竟技术才是硬道理！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之数据结构——数组demo3]]></title>
    <url>%2F2019-04%2Fdata-structure-array-plusone%2F</url>
    <content type="text"><![CDATA[代码维护于GitHub：https://github.com/zrxJuly/data-structure Coding Question:Given a non-empty array of digits representing a non-negative integer, plus one to the integer.The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself. 编程题:给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加1.最高位存放于数组首位，并且数组中的每个元素只包含一个数字.你可以假设该整数除了整数0之外，不会以0开头. 例如： 123输入：[1,2,3]输出：[1,2,4]解释：输入数组表示数字123. 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class PlusOne &#123; /** * |-思路分析：逢十进一 * 从最后一位数组开始向前遍历int数组， * 若最后一位数为9，则将该数值赋为0(逢十进一)，然后依次向前同理， * 若前一位也为9，则赋为0，再向前遍历，若目标数不为9，则该数值+1. * 若数组首位数为0，则需要在数组首位前添加一个数1. * @param digits * @return */ public static int[] plusOne(int[] digits) &#123; // 从数组最后一位数（digits.length-1）开始判断，若&lt;9，直接+1，若=9，采用逢十进一方法. int dIndex = digits.length-1; boolean isContinue = true; while (isContinue &amp;&amp; dIndex &gt;= 0) &#123; if (digits[dIndex] &lt; 9) &#123; digits[dIndex] += 1; isContinue = false; &#125; else &#123; digits[dIndex] = 0; &#125; dIndex --; &#125; // while循环转化后若首位为0，则在原数组首位前需加一位1. if (digits[0] == 0) &#123; int[] newDigits = new int[digits.length+1]; newDigits[0] = 1; for (int i = 1; i &lt; digits.length; i ++) &#123; newDigits[i] = digits[i-1]; &#125; return newDigits; &#125; return digits; &#125; /** * |-More Simple Solution: * */ public static int[] plusOneSimple (int[] digits) &#123; int dIndex = digits.length-1; for (int i = dIndex; i &gt;= 0; i --) &#123; if (digits[i] &lt; 9) &#123; digits[i] += 1; return digits; &#125; // if ==9 digits[i] = 0; &#125; // 显然，上面for循环遍历完成后若走到该方法，说明数组首位为逢十进一数. int[] newDigits = new int[digits.length+1]; newDigits[0] = 1; return newDigits; &#125; public static void main(String[] args) &#123; int[] digits = &#123;9,8,9,9&#125;;// int[] result = plusOne(digits);// System.out.print("result is:");// for (int i = 0; i &lt; result.length; i ++) &#123;// System.out.print(result[i] + ",");// &#125; int[] result2 = plusOneSimple(digits); System.out.print("result2 is:"); for (int i = 0; i &lt; result2.length; i ++) &#123; System.out.print(result2[i] + ","); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>LeetCode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你，有多久没有好好努力过了？]]></title>
    <url>%2F2019-03%2Ffighting%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;你，有多久没有好好努力过了？ &emsp;&emsp;学生党也好，上班族也好，亦或是在经营家庭的你也好，你有多久没有好好努力过了？ &emsp;&emsp;为自己、为你的将来，为你想要的生活，为你内心深处那永不破灭的梦想，你，有多久没有好好努力过了？ &emsp;&emsp;我不知道你是否和我一样，二十多岁的年纪，心里怀揣着对自己未来的无限憧憬，每日看着那激励人心的鸡汤，在心里暗暗发誓，一定要好好努力，过上自己想要的生活。然而，自己却是「行动上的矮子」，没有一点斗志，好像对生活没有了激情，失去了战斗力。 &emsp;&emsp;我迷茫了。 &emsp;&emsp;现在，每天除了工作，剩余时间好像都不是自己的，甚至更可怕的是，连工作也不走心了。我的时间，被一个叫做「懒惰」的东西偷走了。不，准确的说，并非「偷」走，而是我的「拱手相让」，以致我不能支配自己的时间。这样的生活，从何时开始的？或许一个月前，或许去年。不管什么时候，现在的我，确是有很强烈的危机感。 &emsp;&emsp;我害怕了。 &emsp;&emsp;二十多岁的年纪，本应是一个积极向上的年纪，而我却在明明知道走错路的情况下，继续向前走，一步错，步步错。我曾经告诫过自己，不管什么事情，「不贰过」，然而在很多事情上，我并没有做到。 &emsp;&emsp;你知道吗，慢慢的变成一个「不思进取、不求上进」的人是多么可怕，可怕到连你自己都害怕自己。 &emsp;&emsp;亦是如此可悲。 &emsp;&emsp;扪心自问，还是原来的自己吗？还是曾经那个做事积极努力、达不到目标后不甘心要更努力的自己吗？不是了。 &emsp;&emsp;曾经的你，或许很笨，但是你努力做好每一件事情，认真踏实；曾经的你，或许自卑，但是你会去追求自己的梦想、憧憬所有美好的生活，勇敢无畏；曾经的你，会让自己骄傲…… &emsp;&emsp;甘心吗？甘心就这样了吗？ &emsp;&emsp;当然不甘心。 当你觉得为时已晚的时候,恰恰是最早的时候。 &emsp;&emsp; 所以，无论你现在是什么样的状态，一定要找到自己最佳的状态，每天为自己加油，做回那个充满活力、积极向上的你。 &emsp;&emsp;做最好的自己。 &emsp;&emsp;要有前程可奔赴，亦有岁月可回首。 &emsp;&emsp;这句话，送给你，更送给我自己。 &emsp;&emsp;【公众号：这世界独一无二的你 (请于微信内打开该链接)】]]></content>
      <categories>
        <category>媛思</category>
      </categories>
      <tags>
        <tag>媛思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CRUD」真的简单吗？]]></title>
    <url>%2F2019-01%2FCRUD%2F</url>
    <content type="text"><![CDATA[“天天做增删改查，一点进步都没有。”“增删改查，太简单了！”“全都是增删改查，一点技术含量都没有。” &emsp;&emsp;以上，是我听到的好多编程人员说过的话。CRUD，增(Create)、读取查询(Retrieve)、更新(改，Update)、删除(Delete)。都说CRUD简单，CRUD真的简单吗？你可能会说是，但“初出茅庐”的我并不这样觉得。&emsp;&emsp;本人做项目经验不长，写程序过程中总结的一些问题，特此记录下来： 查询1.列表数据显示，是否判断了null及undefined的情况？&emsp;&emsp;&quot;&quot;空字符串还好，如果数据返回到前端有属性为&quot;&quot;,页面显示直接是空的，不过为了好看一些，有的必要加上-替代下空，也是可以的。&emsp;&emsp;null和undefined空值和未定义的值，数据返回到前端为null或undefined，这类数据就得判断一下了（当然，像vue等一些前端框架本身就处理了这些问题，如果前端数据为null或undefined，页面显示直接是空），如果不判断，用户看到实际为null或undefined这样的数据，肯定一头雾水了。 2.查询时，是否用ORDER BY将数据升序或降序排序了？&emsp;&emsp;列表数据显示时，很多情况下是有必要将数据进行排序的。像有日期类型的字段，考虑有些是否需要用ORDER BY DESC降序排列下，像主键若是自增的，是否按主键ORDER BY了等等。如果不排序，数据显示的就会特别乱，比如用户刚添加了一条数据，本应该在列表中显示在第一行，一眼可看到的，但是找了好几页都没有找到，这就有问题了，这就是由于查询时没有对数据进行排序造成的。更可怕的是如果分页功能有问题，数据已经有很多页，而我添加的数据并没有在第一页显示，点分页又没作用，这可如何是好=.=(本人之前遇到过这种问题，所以吃一堑，长一智)。 3.像带有状态条件的数据，查询时是否根据相应条件正确过滤了数据？&emsp;&emsp;如一个表中用status字段标识数据的可用性，0-正常；1-冻结；2-已删除，那么查询的时候status=2甚至status=1的数据就不能查询出来显示到页面中，你在查询的时候是否用WHERE STATUS=0来将数据过滤了？（这只是举了个栗子，当然还是按需求来） 删除&emsp;&emsp;删除，分为软删除 和 硬删除。&emsp;&emsp;所谓软删除就是删除时保留数据库表中相应记录，只是用UPDATE语句更新表中某个状态字段，标识为已删除(eg:第一部分第3条中提到的栗子)，而列表显示的时候是需要过滤掉这个字段中已删除的状态的。&emsp;&emsp;硬删除，也就是永久删除。使用DELETE语句，彻底将相应记录从数据库表中删除。&emsp;&emsp;做删除功能的时候，考虑到业务逻辑相关，其他表的相关字段是否需要清空？其他表的相关记录是否也需要一起删除或更新？这些都是要考虑到的。业务逻辑简单还好，要是复杂了，考虑的必定也就多了。 添加or修改&emsp;&emsp;对于数据的添加，如果表中字段没有设置初始默认值，需要注意添加的时候需要添加上；修改时同理，哪些字段该修改，哪些字段是不必要或不可修改的，这需要好好熟悉理解业务。……[其他的遇到坑了再补充吧~ ] 总结&emsp;&emsp;如果开发时期不注意相关细节，那么测试的时候就会面临代码的重复甚至大量修改，会非常麻烦。不管在查询、添加、修改还是删除，都需要根据业务、表中相应状态字段等等，去进行验证、匹配，确保数据的正确性、一致性。业务越复杂，表之间的关联关系也就越复杂，所以要很熟悉数据库表与表之间的关联关系，熟悉业务，这样做起来会很容易些。其实每写一个SQL，每做一次增删改查，都要从整个业务的关联关系角度思考下，这个事务是否会对其他业务有影响，有什么影响，怎么做是正确的。实践越多，犯错误无可避免，也会越多，自然总结的就会更多。要常常自我反省。正所谓吾日三省吾身，会省才会有进步。]]></content>
      <categories>
        <category>媛思</category>
      </categories>
      <tags>
        <tag>程序性思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活，总归待我不差[致我的2018]]]></title>
    <url>%2F2018-12%2Fhappyending-2018%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;2018年，算是人生中非常重要的一年。这一年，我离开校园，真正走向社会，像刚出巢的鸟儿，扑楞着那还没长硬的翅膀，在天空中探寻着属于自己的方向；这一年，努力过，迷茫过，期待过，失望过，开心过，沮丧过；这一年，错过了许多机会，但也足够幸运；这一年，来到了自己曾梦寐以求的城市，过着自己喜欢的生活；这一年，遇到了对我人生中有很重要影响的人，或良师，或益友；这一年，失去了很多宝贵的东西，但我也可以安慰自己：生活，总归待我不差。&emsp;&emsp;离开校园，步入职场。校园外的世界并没有想象中的那么可怕。对未来充满无限期待。做着自己喜欢的工作，努力着，累但快乐着。但是，几个月后，突然厌倦了这种生活，特别讨厌，或许是后来着手了自己不太喜欢的工作内容，亦或者没有了压力、动力，对工作、生活没有了积极性，我变得懒惰，变得对生活没有热情，迷失了方向，变得更加迷茫。知道自己再这样下去会变得越来越颓废，我觉得我该换一个环境，换一种生活，因此，毕业后一个月内，我提出了离职，离开时，正好在公司半年。&emsp;&emsp;心心念了好久的考研计划就此搁置，或许，这让我失去了很多重要的机会。只身一人，去往自己向往的城市，期待着自己向往的生活，然而，并不像想象中那样顺利。工作，足有二十余天才定下来，这期间，失望、无助，有时候还会想，是不是就要回去了，但是自己不甘心，我并不觉得我哪里差了。失望之际，算是遇上了人生中一伯乐，之后又遇到人生又一导师。我，足够幸运。工作这段时间，挑战了自己身体的极限，心灵的极限，自己也没想到，我原来可以承受这么多。有压力才会有动力，才会让自己飞速成长。 &emsp;&emsp;这一年，过得太快太快了，所有的经历仿佛都在昨天。我相信，每一次经历，都是一种成长；我期待，2019年，这更加有挑战性的一年；我希望，遇见更优秀的自己。]]></content>
      <categories>
        <category>人生</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令学习总结]]></title>
    <url>%2F2018-12%2Flinux-study-01%2F</url>
    <content type="text"><![CDATA[Windows连接Linux服务器常用工具使用winscp&emsp;&emsp;Winscp是Windows环境下的图形化SFTP客户端，同时支持SCP协议。主要功能是实现在本地与远程计算机之间安全的复制文件。winscp可连接Linux系统。 SecureCRT&emsp;&emsp;Windows下登录UNIX或Linux服务器主机的软件。 Linux常用命令新建文件1touch filename 例：新建一个名为zrxJuly的txt文件。 1touch zrxJuly.txt 新建目录1mkdir directory 例：新建一个名为zrxJuly的目录(文件夹) 1mkdir zrxJuly 查看文本内容 命令 描述 实例 cat filename 从第一行开始显示所有的文本内容 cat zrxJuly.txt tac filename 从最后一行开始显示所有文本内容,与cat相反 tac zrxJuly.txt nl filename 显示文本，输出行号 nl zrxJuly.txt more filename 按页显示文本内容 more zrxJuly.txt tail -f 实时查看日志文件 tail -f web.log #### 压缩文件(zip) 1zip 参数 打包后的文件名 打包的目录路径 例： 1zip zrxJuly.zip zrxJuly 解压文件(zip) 命令 描述 实例 unzip zipName 解压文件到当前目录 unzip zrxJuly.zip unzip -o zipName 解压时不询问直接覆盖 tac zrxJuly.txt unzip zipName -d directory 将文件解压到指定文件夹 unzip zrxJuly.zip -d /data/bak unzip -v zipName 查看压缩包内容但不解压 unzip -v zrxJuly.zip zcat gzName 查看压缩后的文件内容 zcat zrxJuly.gz #### 复制文件及文件夹到指定目录 将aa复制到/aa/bb目录下 1cp -rf aa /aa/bb aa: 要复制的文件或文件夹/aa/bb:将文件或文件夹复制到的指定目录 移动文件到指定目录移动file到tofile目录中： 1mv file tofile 删除文件1rm -rf file 该命令强制删除file及file目录下的所有文件，如果没有-r，则不会删除目录。-f：忽略不存在的文件，强制删除，不给出提示；-r：指示rm将参数中列出的全部目录和子目录均递归地删除；-i：进行交互式删除。 vim 查看或编辑文件 1vi filename vim编辑模式下快捷键 命令 描述 ctrlb或键盘ctrl+B 向上翻页 ctrlf或键盘ctrl+F 向下翻页 ESC，/hello 关键词搜索：vim下，按ESC进入命令模式，若查询关键词“hello”，则输入 /hello 进行查找； gg 跳至文件首行 dG 清空整个文件 :wq，回车 保存并退出 :wq!，回车 强制保存退出 :q，回车 退出vim编辑 :q!，回车 强制退出编辑 i，ESC 插入内容：输入i，进行内容编辑，完成后按ESC退出编辑 tomcat服务器启动与关闭cd到tomcat的bin目录下，启动服务器命令：./startup.sh查看log日志：tail -f ../logs/catalian.out关闭服务：./shutdown.sh 或者： sh catalian.sh startsh catalian.sh stop]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jasypt对SpringBoot配置文件加密]]></title>
    <url>%2F2018-12%2FSpringBoot-Jasypt%2F</url>
    <content type="text"><![CDATA[一、Jasypt介绍&emsp;&emsp;Jasypt(Java Simplified Encryption)，为开发人员提供一种简单的方式来为项目增加加密功能，包括：密码Digest认证，文本和对象加密，集成hibernate、Spring Security来增强密码管理。Jasypt1.4新特性：加密属性文件、Spring Framework集成、加密Hibernate数据源配置、新的命令行工具、URL加密的Apache wicket集成、升级文档。 二、Jasypt作用1.加密任务与应用程序。例如：加密密码、敏感信息和数据通信、创建完整检查数据的sums。2.包括高安全性、基于标准的加密技术、可同时单向和双向加密的加密密码、文本、数字和二进制文件。3.符合RSA标准的基于密码的加密，并提供了无配置加密工具以及新的、高可配置标准的加密工具。4.加密属性文件（encryptable properties files）、Spring work集成、加密Hibernate数据源配置、新的命令行工具、URL加密的Apache wicket集成以及升级文档。 三、使用Jasypt对SpringBoot配置文件加密1.pom.xml中引入依赖123456&lt;!-- jasypt加密依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.16&lt;/version&gt;&lt;/dependency&gt; 2.application.yml配置文件中配置加密所需的salt(盐)1234# jasypt用于数据库url及密码加密.jasypt: encryptor: password: zrxJuly 3.加密这里给配置文件中的链接数据库的用户名及密码加密。新建一个工具类JasyptUtil，main方法中加密代码示例如下： 1234567891011public static void main(String[] args) &#123; BasicTextEncryptor textEncryptor = new BasicTextEncryptor(); //1.加密所需的salt(盐)，此处的值要与application中的配置的password一样。 application.yml中配置：jasypt.encryptor.password=zrxJuly textEncryptor.setPassword("zrxJuly"); //2.要加密的数据.运行完main方法后，将打印出的加密内容在application.yml相关参数中替换： String user = textEncryptor.encrypt("postgres"); String password = textEncryptor.encrypt("zrx"); // application.yml中替换：ENC(jdbcUrl) ENC(password) System.out.println("user:"+user); System.out.println("password:"+password);&#125; 运行main方法，结果如下： 12user:leMoA9uT7nBUbd/oNSzl+tzbjBRyeRGkpassword:jLKpSiNXZ0EQKnryRhMgVg== 将配置文件application.yml中的数据库的用户名及密码替换为上述结果。加密字符串要在ENC()中。 12user: ENC(leMoA9uT7nBUbd/oNSzl+tzbjBRyeRGk)password: ENC(jLKpSiNXZ0EQKnryRhMgVg==) 运行项目，看数据库是否能连接上，若能正常链接，则加密成功。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Jasypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Gson解析复杂的json数组]]></title>
    <url>%2F2018-10%2Fanalysis-json%2F</url>
    <content type="text"><![CDATA[前端使用Ajax传值到后端代码示例如下： 1234567891011121314151617var postData = [];var json1 = &#123;"a":"a","b":"b"&#125;;var jsonArray = [&#123;"id":"a","name":"zrxJuly"&#125;,&#123;"id":"b","name":"Anna"&#125;,&#123;"id":"c","name":"Andy"&#125;];postData.push(&#123;"json1":json1&#125;);postData.push(&#123;"jsonArray":jsonArray&#125;);$.ajax(&#123; type : "post", url : "/test", data : &#123;testData:JSON.stringify(postData)&#125;, dataType : "json", success : function(data) &#123; console.log('成功后的回调函数'); &#125;, error : function() &#123; console.log('失败后的回调函数'); &#125;&#125;); 后端接收前端传来的数据 后端SpringBoot接收前端数据及处理,使用Gson解析json. 1234567891011121314151617181920212223242526272829303132333435@PostMapping(value = "/test", produces = &#123; MediaType.APPLICATION_JSON_UTF8_VALUE &#125;)public void test(String testData) throws Exception &#123; // JSON数据格式： // [&#123;"A":"Anna","B":"Bob"&#125;,&#123;"json1":&#123;"A":"a","B":"b"&#125;&#125;,&#123;"jsonArray":[&#123;"A":"a","B":"zrxJuly"&#125;,&#123;"A":"b","B":"Anna"&#125;,&#123;"A":"c","B":"Andy"&#125;]&#125;] //String testData = "[&#123;\"A\":\"Anna\",\"B\":\"Bob\"&#125;,&#123;\"json1\":&#123;\"A\":\"a\",\"B\":\"b\"&#125;&#125;,&#123;\"jsonArray\":[&#123;\"A\":\"a\",\"B\":\"zrxJuly\"&#125;,&#123;\"A\":\"b\",\"B\":\"Anna\"&#125;,&#123;\"A\":\"c\",\"B\":\"Andy\"&#125;]&#125;]"; System.out.println("=================获取的json：============="); System.out.println(testData); // 1.将该json数组字符串转化为json数组对象. JSONArray dataJson = JSONArray.fromObject(testData); // 获取数组元素,数组内元素都是json. // 获取第一种json. System.out.println("======获取第一种json:"+dataJson.get(0)); // 映射为对象. Json1 json1 = new Gson().fromJson(dataJson.get(0).toString(), Json1.class); System.out.println(json1.getA()); System.out.println(json1.getB()); System.out.println(json1.toString()); // 获取第二种json. key:value形式. System.out.println("======获取第二种json. key:value形式："+dataJson.get(1)); // 将获取的值解析为Json对象. JsonObject jsonObject2 = (JsonObject) new JsonParser().parse(dataJson.get(1).toString()); // 映射为对象. Json1 json11 = new Gson().fromJson(jsonObject2.get("json1"), Json1.class); System.out.println(json11.getA()); System.out.println(json11.getB()); System.out.println(json11.toString()); // 获取第三种json：json数组 System.out.println("======获取第三种json：json数组："+dataJson.get(2)); JsonObject jsonObject3 = (JsonObject) new JsonParser().parse(dataJson.get(2).toString()); List&lt;Json1&gt; json1List = new Gson().fromJson(jsonObject3.get("jsonArray"), new TypeToken&lt;List&lt;Json1&gt;&gt;() &#123;&#125;.getType()); for (int i = 0; i &lt; json1List.size(); i ++) &#123; System.out.println(json1List.get(i).getA()+":"+json1List.get(i).getB()); &#125;&#125; 在解析json取值前，我们需要将json对象映射为我们实体类中的对象,需要建立json的映射Bean. 12345678910111213141516171819202122232425/** * @author zrxJuly * @Description json的映射Bean. */public class Json1 &#123; private String A; private String B; public String getA() &#123; return A; &#125; public void setA(String a) &#123; A = a; &#125; public String getB() &#123; return B; &#125; public void setB(String b) &#123; B = b; &#125; @Override public String toString() &#123; return "Json1 [A=" + A + ", B=" + B + "]"; &#125; &#125; 输出结果如下：]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>json解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启我的另一种生活]]></title>
    <url>%2F2018-09%2Fsecond-life-start%2F</url>
    <content type="text"><![CDATA[人生的道路虽然漫长，但紧要之处往往只有几步，特别是当人年轻的时候。没有一个人的生活道路是笔直的、没有岔道的。有些岔道口，譬如政治上的岔道口，事业上的岔道口，个人生活上的岔道口，你走错一步，可以影响人生的一个时期，也可以影响一生。————柳青 &emsp;&emsp;读路遥的《人生》，序言中引用的柳青的这段话让我很受感触，摘抄下来。人生真的是很奇妙，对吧？有时当我身旁寂静无人的时候，心底总是会不由自主地思考一些关于自己的源和终的问题，我是谁？我在哪儿？我在干什么？我的未来会是什么样子？未来的我会有大作为吗？谁将与我共度余生？我老了会是什么样子？死后呢？我死后还会有思想吗？人的思想应是出生时就被赋予，有没有想过，死后，当然肉体是归于尘土，但你的思想呢？精神呢？是否也随肉体长埋地下？一系列的问题又将自己带入了迷茫的状态。未来的一切，都是那么扑朔迷离，吊人胃口，让人期待。每次这样问自己的时候，不知道哪里的强大的力量，总是会告诉自己，我的人生注定是不平凡的，总觉得自己肯定会做出一些“惊天动地”的事情。&emsp;&emsp;然而，事实上，现在的我并没有什么大作为，没有做一些对社会有突出贡献、惊天动地之事让众人知道自己，记住自己的名字，也并没有实现自己的人生价值，虽然自己也不知道怎样才算是实现了自己的人生价值。我现在21岁，其实这个年纪算是我人生的一个转折点，我知道在我21岁这个人生岔道口上，我走的每一步，做出的每一个选择，都会对我以后的人生产生很大影响。 &emsp;&emsp;想起了去年年底学期末，一七年的10-11月份，那时还在校，自己一直纠结考研还是工作的问题。考研，也忘记了是什么时候开始有的这个打算，应该是刚入学的时候，因为自己的不甘心，先是报了自考班，之后在课上老师也鼓励我们考研，所以这个想法在心中扎根，一直到现在。当时加了好多考研群，也面临选专业、选学校。专业不用纠结，软件工程，是自己喜欢的。学校的话当时也不知道怎么选择，各方面优劣，当时都想把研招网上的一些学校的报录比等信息爬出来，不过并没有，当时应该是忙着考试，也搁置了，之后也很快定好了学校。前期工作准备好了，自己又纠结，如果我选择考研，那么我将近一年不会工作，肯定也不可能住在家里，考虑到租金、日常生活等资金方面，是很大的问题。再有，努力了一年，考上了还好，但是如果得不到我想要的结果怎么办？那么我还得面临找工作，一年，技术更新的太快了，那个时候我都不知道落后到哪里去了，想想也害怕。工作，可以赚钱，可以学到新技术，可以认识新同事，更能够锻炼自己，但是，梦想就此搁置，不甘心啊。也许你会说可以边工作边考研啊，但是怕自己没有那么多精力，赔了夫人又折兵。想了很久，其实心中也早已有了答案，但是还是左右摇摆不定。咨询老师，帮我分析，一方面，现在复习，战线会拉的太长，到最后关头或许就厌了；另一方面，实习能够学到很多东西，怕我失去这次锻炼自己的机会，先等工作稳定，说不定两方面都能兼顾了呢？嗯，心中的答案更加坚定了，工作吧。&emsp;&emsp;年底开始找工作，写简历，投简历，回应的却很少，打电话邀请面试的却是很多的，不过全部都是培训公司，自己当时却是没经验，分不清，傻傻的面试了几家，不过长经验了。同学也是，好多都是培训公司打来的电话，在这里就想吐槽一下，培训公司借着招人的名义，约面试，最后让你培训，真的是很不靠谱了。就这样，年前就面试了几家培训公司，放弃找工作，回家，开开心心的过最后一个寒假。年后初六离家去找工作，在这里感谢我找工作期间收留我的好姐妹。第六天收到第一个面试邀请，第九天正式上班。第一次找工作还算顺利，对口，待遇不错，老板同事也都很好，入职后，每天都很充实，对未来充满期待，但到第三个月，安排了自己并不太喜欢的工作，与自己之前面试时候的工作不同，而且一干就是三四个月，开始着与自己职业规划不符的工作，心里落差挺大的，对当时的工作，甚至对当时的自己越来越厌恶，终于，七月下旬的时候，我提出了离职，没有一丝犹豫。离职的原因无非就三点：1.不喜欢当时的工作；2.不喜欢当时烦躁无味的生活；3.想要去追求自己的梦想，不想自己的人生就这样度过了。像《谁动了我的奶酪》中的唧唧一样，感受到变化后，应该正确的对自己的变化做出正确的应对，所以，我做出了人生中一个重要的且正确的决定。&emsp;&emsp;做完交接工作后，9月上旬才正式离职，其实那一个多月的时间也是够痛苦的，这期间也对一些人从最初的崇拜到无感再到失望，最后到绝望。前段时间看到过一篇文章，大体是说离职的时候可以检验人品，嗯，有点道理。总之一句话，离职挺难的。工作那半年自己尽自己最大努力工作，也无憾了。&emsp;&emsp;下面才进入正题，前面算是对自己上半年的一个总结吧。9月中旬，开始自己的新生活，一切都是未知的，只有自己清晰的目标和方向。投简历，重新找工作。然而，这次找工作并没有那么顺利，前后二十多天才把工作定下来，不过，只要是自己喜欢的，晚一点也没有关系。现在工作了已有一周时间，有压力，就会有动力，很充实，未来可期，要一直一直好好努力！就先写这么多了吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>我的21岁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL学习笔记（一）——PostgreSQL介绍]]></title>
    <url>%2F2018-09%2Fpostgresql-1%2F</url>
    <content type="text"><![CDATA[PostgreSQL介绍PostgreSQL是一个开源对象关系数据库管理系统（ORDBMS）；用于安全地存储数据；支持最佳做法，并允许在处理请求时检索它们。PostgreSQL是跨平台的，可以在许多操作系统上运行。 PostgreSQL特点： 可在所有主要操作系统上运行； PostgreSQL支持文本、图像、声音和视频，并包括用于C/C++,Java,Python,Ruby和开发数据库链接(ODBC)的编程接口。 PostgreSQL支持SQL的许多功能，例如复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制（MVCC），流式复制，热备。 在PostgreSQL中，表可以设置为从“父”表继承其特性 可以安装多个扩展以向PostgreSQL添加附加功能。 PostgreSQL数据类型 数据类型 指定要在表字段中存储哪种类型的数据。在创建表时，对于每列必须使用数据类型。三种主要的数据类型： 数值 字符串 日期/时间 数值数据类型数字数据类型用于指定表中的数字数据。 名称 描述 存储大小 smallint 存储整数，小范围 2字节 integer 存储整数，使用这个类型可存储典型的整数 4字节 bigint 存储整数，大范围 8字节 decimal 用户指定的精度，精确 变量 numeric 用户指定的精度，精确 变量 real 可变精度，不精确 4字节 double 可变精度，不精确 8字节 serial 自动递增整数 4字节 bigserial 达到自动递增整数 8字节 字符串数据类型String数据类型用于标识字符串类型值。 数据类型 描述 char(size) size：要存储的字符数。固定长度字符串，右边的空格填充到相等大小的字符 character(size) size：要存储的字符数。固定长度字符串，右边的空格填充到相等大小的字符 varchar(size) size：要存储的字符数。可变长度字符串。 character varying(size) size：要存储的字符数。可变长度字符串。 text 可变长度字符串。]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之数据结构——数组demo2]]></title>
    <url>%2F2018-09%2Fdata-structure-array-LargestNumber%2F</url>
    <content type="text"><![CDATA[Coding Question:In a given integer array nums, there is always exactly one largest element.Find whether the largest element in the array is at least twice as much as every other number in the array.If it is, return the index of the largest element, otherwise return -1.编程题：给定一个数组，总是存在一个最大元素。查找数组中的最大元素，该元素是否至少是数组中其他每个元素的两倍。如果是，返回最大元素的索引，否则返回-1。思路： 首先，将给定数组中最大的元素查询出来 然后，遍历数组中的元素，比较数组中最大元素是否大于或等于除最大元素的其他每个元素的两倍 下面看代码： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.zrxjuly.ds.arrayandstring.demo;/** * @author zrxJuly */public class LargestNumber &#123; public static void main(String[] args) &#123; int nums[] = &#123;0,0,1,1&#125;; int result = largestNum(nums); System.out.println("The result number is:" + result); &#125; public static int largestNum(int[] nums) &#123; // 假定数组中最大的数为数组的第一个数. int maxNum = nums[0]; // 第一个数的下标值. int maxNumIndex = 0; // 先找出数组中最大的数. for (int m = 0; m &lt; nums.length; m ++) &#123; for (int n = m; n &lt; nums.length; n ++) &#123; if (nums[n] &gt; maxNum) &#123; maxNum = nums[n]; maxNumIndex = n; &#125; &#125; &#125; // 输出查看遍历后的最大数与最大数的下标. System.out.println("maxNum:"+maxNum); System.out.println("maxIndex:"+maxNumIndex); // 遍历数组，判断数组内某个元素值*2是否小于或等于maxNum，是：返回maxIndex，否：返回-1 for (int i = 0; i &lt; nums.length; i ++) &#123; if (i == maxNumIndex) continue; if (nums[i] * 2 &gt; maxNum) &#123; return -1; &#125; &#125; return maxNumIndex; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>LeetCode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之数据结构——数组]]></title>
    <url>%2F2018-08%2Fdata-structure-array%2F</url>
    <content type="text"><![CDATA[从今天开始刷LeetCode，目标：每周至少刷一个Coding Question，出一篇data structure学习博文进行总结。Fighting！解出的代码案例也都会在我的GitHub上进行维护。如果觉得对您有帮助，欢迎star or fork~附上GitHub项目地址：https://github.com/zrxJuly/dataStructure。本文首发于我的个人博客：zrxJuly’s Blog，欢迎访问，Let’s study together. 数组简介&emsp;&emsp;数组是数据结构中的基本模块之一，因为字符串是由字符数组形成的，所以二者是相似的。数组是一种基本的数据结构，用于按顺序存储元素集合，数组中的每个元素都可以通过数组索引来识别，元素可以随机存取。数组可以有一个或多个维度，&emsp;&emsp; 一维数组：也叫线性数组。数组具有固定的容量，我们需要在初始化时指定数组的大小。然而这种在初始化时指定数组大小的方法会很不方便甚至可能会造成浪费。 Array Demo学习123456789101112131415161718192021222324252627282930313233343536package com.zrxjuly.ds.arrayandstring.study;import java.util.Arrays;/** * @Description 数组的基本用法. */public class Array &#123; public static void arrayTest() &#123; // 1. Initialize.初始化数组. int[] a0 = new int[5]; int[] a1 = &#123; 1, 2, 3 &#125;; // 2. Get Length.输出数组长度. System.out.println("The size of a1 is: " + a1.length); // 3. Access Element.访问数组元素. System.out.println("The first element is: " + a1[0]); // 4. Iterate all Elements.遍历所有元素，两个for循环，两种遍历方法. System.out.print("[Version 1] The contents of a1 are:"); for (int i = 0; i &lt; a1.length; ++i) &#123; System.out.print(" " + a1[i]); &#125; System.out.println(); System.out.print("[Version 2] The contents of a1 are:"); for (int item : a1) &#123; System.out.print(" " + item); &#125; System.out.println(); // 5. Modify Element.修改指定下标的数组元素. a1[0] = 4; // 6. Sort.对数组进行排序. Arrays.sort(a1); &#125; public static void main(String[] args) &#123; arrayTest(); &#125;&#125; 动态数组简介动态数组：是大小可变的随机存取的列表数据结构。大多数编程语言都会提供内置的动态数组。eg：在C++中的vector，Java中的ArrayList。 Dynamic Array Demo 学习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.zrxjuly.ds.arrayandstring.study;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * @Description 动态数组 * 大小可变的随机存取的列表数据结构. */public class DynamicArray &#123; public static void dynamicArray() &#123; // 1. 集合初始化. List&lt;Integer&gt; v0 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; v1; // 声明并赋值数组. Integer[] a = &#123;0, 1, 2, 3, 4&#125;; // Arrays.asList()方法：将数组转化为List，该方法将数组与列表链接起来，当更新其中一个时，另一个也会更新. v1 = new ArrayList&lt;&gt;(Arrays.asList(a)); // 3. 将v1数组赋值给v2 List&lt;Integer&gt; v2 = v1; // another reference to v1 List&lt;Integer&gt; v3 = new ArrayList&lt;&gt;(v1); // make an actual copy of v1 // 3. get length System.out.println("The size of v1 is: " + v1.size());; // 4. access element System.out.println("The first element in v1 is: " + v1.get(0)); // 5. iterate the vector.下面两种方法遍历集合内容. System.out.print("[Version 1] The contents of v1 are:"); for (int i = 0; i &lt; v1.size(); i ++) &#123; System.out.print(" " + v1.get(i)); &#125; System.out.println(); System.out.print("[Version 2] The contents of v1 are:"); for (int item : v1) &#123; System.out.print(" " + item); &#125; System.out.println(); // 6. modify element.修改元素，注意：v1使用Arrays.asList()方法赋值，因此v2中的元素修改后，v1也会修改 v2.set(0, 5); // modify v2 will actually modify v1 System.out.println("The first element in v1 is: " + v1.get(0)); v3.set(0, -1); System.out.println("The first element in v1 is: " + v1.get(0)); // 7. sort. 对集合进行排序 Collections.sort(v1); // 8. add new element at the end of the vector v1.add(-1); System.out.print("[Version 2] The contents of v1 are:"); for (int item : v1) &#123; System.out.print(" " + item); &#125; System.out.println(); v1.add(1, 6); System.out.print("[Version 2] The contents of v1 are:"); for (int item : v1) &#123; System.out.print(" " + item); &#125; System.out.println(); // 9. delete the last element v1.remove(v1.size() - 1); System.out.print("[Version 2] The contents of v1 are:"); for (int item : v1) &#123; System.out.print(" " + item); &#125; &#125; public static void main(String[] args) &#123; dynamicArray(); &#125;&#125; Coding Question:寻找数组的中心索引该Coding Question是LeetCode上数组模块的第一个编程问题。这里展示了两种解题思路及方法：思路一目标索引的左侧的数的总和 = 目标索引的右侧的数的总和。思路二左侧及索引对应的数 的总和+索引对应的数 = 总和-左侧及索引对应的数的总和+索引对应的数。 详细分析请看代码及注释，或访问：https://github.com/zrxJuly/dataStructure 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.zrxjuly.ds.arrayandstring.demo;/** * * @author: zrxJuly * @Date: 2018-8-21 17:00:55 * @Desription: Find Pivot Index. 寻找数组的中心索引。 * Coding Question: * Given an array of integers nums, write a method that returns the "pivot" index of this array. * We define the pivot index as the index where the sum of the numbers to the left of the index * is equal to the sum of the numbers to the right of the index. * If no such index exists, we should return -1. * If there are multiple pivot indexes, you should return the left-most pivot index. * |-题目：寻找数组的中心索引。 * 给定一个整数类型的数组，编写一个返回数组中心索引的方法。 * 数组中心索引的定义：索引左侧的数的总和 = 索引右侧的数的总和。 * 如果不存在这样的索引，返回-1. * 如果存在多个中心索引，应该返回最左侧的中心索引。 * */public class FindPivotIndex &#123; /** * Solution 1. * |-思路分析：目标索引的左侧的数的总和 = 目标索引的右侧的数的总和. * 数组：[1, 7, 3, 6, 5, 6 ] * |______| | |___| * | | | * A B C * 假设 A：目标索引左侧的总和，C:目标索引右侧总和，B：目标索引对应的数值. * 则 若有：A = C， 符合题意，返回B的索引，否则返回-1. * |- 分别声明左侧总和numsLeft 以及 右侧总和numsRight 两个变量，for循环分别遍历两侧元素，最后比较是否相等. * @param nums * @return */ public static int pivotIndexSolution1(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; // 声明左侧变量. int numsLeft = 0; // 声明右侧变量. int numsRight = 0; // 遍历i左侧元素，值相加. for (int m = 0; m &lt; i; m++) &#123; numsLeft += nums[m]; &#125; // 遍历i右侧元素，值相加. for (int n = nums.length - 1; n &gt; i; n--) &#123; numsRight += nums[n]; &#125; // 若左侧值和右侧值相等，返回i值. if (numsLeft == numsRight) &#123; return i; &#125; &#125; return -1; &#125; /** * Solution 2. * |-思路分析：左侧及索引对应的数 的总和+索引对应的数 = 总和-左侧及索引对应的数的总和+索引对应的数. * |-下面这样解释更容易理解： * 数组：[1, 7, 3, 6, 5, 6 ] * |______| | |___| * | | | * A B C * 假设 A：目标索引左侧的总和，C:目标索引右侧总和，B：目标索引对应的数值. * 则 若有：A + B = B + C，即 A = C， 符合题意，返回B的索引，否则返回-1. * * |-下面代码中是这样判断的： * 分别声明两个变量：数组总和sum 以及 数组左侧总和 lsum * 先用for循环遍历得出数组总和sum，然后再写一个for循环，在该循环内判断左侧总和lsum是否和右侧总和相等。 * (注：本例中lsum包含了目标索引的值，因此在判断的时候右侧总和也必须加上目标索引的值) * * @param nums * @return */ public static int pivotIndexSolution2(int[] nums) &#123; int len = nums.length; // 数组总和. int sum = 0; // 数组左侧数的总和. int lsum = 0; // 得出数组总和. for(int x:nums)&#123; sum+=x; &#125; for(int i = 0;i&lt;len;i++)&#123; lsum += nums[i]; // 判断：左侧总和 == 右侧总和 if(lsum == sum - lsum + nums[i])&#123; return i; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; // Initialize.初始化数组. int[] nums = &#123;1, 7, 3, 6, 5, 6&#125;;// int[] nums = &#123;-1,-1,-1,0,1,1&#125;; // 调用方法一： int result1 = pivotIndexSolution1(nums); System.out.println("The first method result is:" + result1); // 调用方法二： int result2 = pivotIndexSolution2(nums); System.out.println("The second method result is:" + result2); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>LeetCode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记（三）——Redis键(key)]]></title>
    <url>%2F2018-08%2Fredis-study-3%2F</url>
    <content type="text"><![CDATA[Redis 键命令用于管理Redis的键。 语法： 1command keyName Redis键命令 列举部分redis键相关的基本命令 DEL key 删除已存在的键。不存在的key则会被忽略。 语法： 1DEL keyName 返回值：被删除key的数量。例： 12345678127.0.0.1:6379&gt; set name &quot;zrx&quot;OK127.0.0.1:6379&gt; get name&quot;zrx&quot;127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; get name(nil) EXISTS key 用于检查指定的key是否存在。 语法： 1EXISTS keyName 返回值：key存在返回1，否则返回0。例： 12345678127.0.0.1:6379&gt; set name &quot;a&quot;OK127.0.0.1:6379&gt; exists name(integer) 1127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; exists name(integer) 0 EXPIRE key seconds 设置key的过期时间。key过期后将不再可用。语法: 1expire key seconds 返回值：设置成功返回1，key不存在或不能为key设置过期时间时返回0。例： 12127.0.0.1:6379&gt; expire name 20(integer) 1 PERSIST key 移除给定key的过期时间，使得key永不过期。 1PERSIST keyName 过期时间移除成功时，返回1，key不存在或key没有设置过期时间，返回0。 RENAME old_key new_key 修改key的名称。 修改成功时提示OK，失败时返回一个错误。 TYPE keyName 返回key所存储的值的类型。 返回key的数据类型有： none ：key不存在 string：字符串 list：列表 set：集合 zset：有序集 hash： 哈希表 keys pattern 查找所有符合给定模式的key。 获取redis中所有的key： 1keys * 参考资料http://www.redis.net.cn/order/3528.html]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记（二）——Redis数据类型]]></title>
    <url>%2F2018-08%2Fredis-study-2%2F</url>
    <content type="text"><![CDATA[Redis支持5种数据类型： string：字符串 hash：哈希 list：列表 set： 集合 zset：有序集合（sorted set） String：字符串string是Redis最基本的类型，一个key对应一个value；string类型是二进制安全的，即Redis的string可包含任何数据。比如jpg图片或者序列化的对象。string类型是Redis最基本的数据类型，string类型的值最大能存储512MB。 语法格式：set key valueget key 1234127.0.0.1:6379&gt; set name &apos;zrx&apos;OK127.0.0.1:6379&gt; get name&quot;zrx&quot; Redis 命令不区分大小写。上面例子 键为name，值为zrx。使用了set先给name赋值为’zrx’，再使用了get取键对应的值。 Hash：哈希Hash是键值对集合，适用于存储对象。Redis哈希（散列）是字符串字段和字符串值之间的映射。 语法格式：hmset key field valuehget key field 123456789101112127.0.0.1:6379&gt; hmset myhash field1 &quot;hello&quot; field2 &quot;world&quot;OK127.0.0.1:6379&gt; hget myhash field1&quot;hello&quot;127.0.0.1:6379&gt; hget myhash field2&quot;world&quot;127.0.0.1:6379&gt; hmset myhash name &quot;zrx&quot; age &quot;twenty&quot;OK127.0.0.1:6379&gt; hget myhash name&quot;zrx&quot;127.0.0.1:6379&gt; hget myhash age&quot;twenty&quot; hmset 设置field=&gt;value对，hget获取对应field对应的value。上面例子中field=&gt;value对有：field1=&gt;&quot;hello&quot;,field2=&gt;&quot;world&quot;,name=&gt;&quot;zrx&quot;,age=&gt;&quot;twenty&quot;。 每个hash可以存储232-1个键值对。 List：列表Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或尾部（右边）。 语法格式：lpush key member 12345678910127.0.0.1:6379&gt; lpush list1 good(integer) 1127.0.0.1:6379&gt; lpush list1 study(integer) 2127.0.0.1:6379&gt; lpush list1 up(integer) 3127.0.0.1:6379&gt; lrange list1 0 21) &quot;up&quot;2) &quot;study&quot;3) &quot;good&quot; 列表最大长度为232-1个元素。 Set：集合Redis的set是string类型的无序 集合。集合是通过哈希表实现的，因此添加、删除、查找的复杂度都是O(1)。sadd命令添加一个string元素到key对应的set集合中，成功返回1，元素已在集合中返回0，key对应的set不存在返回错误。 语法格式：sadd key member 123456789127.0.0.1:6379&gt; sadd subject java(integer) 1127.0.0.1:6379&gt; sadd subject html(integer) 1127.0.0.1:6379&gt; sadd subject java(integer) 0127.0.0.1:6379&gt; smembers subject1) &quot;java&quot;2) &quot;html&quot; 值java被添加了两次，但根据集合内元素唯一性，第二次添加的元素将忽略。 集合中最大的成员数为232-1 zset：有序集合（sorted set）添加元素到集合，若元素在集合中存在则更新对应score。 语法格式zadd key score member 12345678910127.0.0.1:6379&gt; zadd zname 0 zs(integer) 1127.0.0.1:6379&gt; zadd zname 0 ls(integer) 1127.0.0.1:6379&gt; zadd zname 0 ww(integer) 1127.0.0.1:6379&gt; ZRANGEBYSCORE zname 0 101) &quot;ls&quot;2) &quot;ww&quot;3) &quot;zs&quot; 参考资料http://www.runoob.com/redis/redis-install.htmlhttps://www.yiibai.com/redis/redis_quick_guide.html]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习笔记（一）——初识Redis]]></title>
    <url>%2F2018-08%2Fredis-study-1%2F</url>
    <content type="text"><![CDATA[Redis介绍 Redis是一个开源、高级的键值存储和一个适用的解决方案，用于构建高性能、可扩展的web应用程序，遵循BSD协议[1]，是一个高性能的key-value数据库。 Redis特点： 支持数据持久化。可将内存中的数据保存在磁盘中，重启时可再次加载使用。 数据结构存储类型丰富，eg：list,set,zset,hash,string等。 支持master-slave模式的数据备份。 Redis优点 性能高，读写速度快。 数据类型丰富。支持大多数数据类型的操作，如列表、集合、排序集、散列。 操作具有原子性。要么成功执行，要么失败都不执行。单个操作是原子性的，多个操作也支持事务原子性。 Redis与同类产品作为高速缓存比较除了Redis，同样可以作为缓存的有Ehcache、Memcached。 Ehcache：Java开源项目，引入jar包即可方便的使用。 Memcached：如果开启多线程模式，读取速度将会有很大提高。数据只会存储于内存中，挂掉后不可恢复。 Redis：数据结构丰富；支持主从、分片等多种高级特性，用于负载均衡和容灾，具有高可用性。 参考资料http://www.runoob.com/redis/redis-install.htmlhttps://www.yiibai.com/redis/redis_quick_guide.htmlhttps://www.cnblogs.com/yiwangzhibujian/p/7053840.html 标注 [1] BSD开源协议：使用者可自由使用、修改源代码，也可将修改后的代码作为开源或者专有软件再发布。BSD鼓励代码共享，但要尊重代码作者的著作权。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub代码查看工具——Sourcegraph插件安装及介绍]]></title>
    <url>%2F2018-08%2Fgithub-plugin-sourcegraph%2F</url>
    <content type="text"><![CDATA[作为编程人员，经常会阅读大神们的代码进行学习，像GitHub上有很多好的开源的代码供我们学习，所以呢，问题就来了，一般的方法阅读代码不光费劲，而且项目结构也不容易搞清楚。偶然发现了一个可以很好地查看代码的工具Sourcegraph，觉得很好。 Sourcegraph介绍简单地说，Sourcegraph是一个帮助我们更好地阅读和理解代码的工具。推荐下面文章：Sourcegraph:开发者的福音 Sourcegraph插件安装解决无法访问Chrome网上应用商店的问题：http://www.xiazaiba.com/jiaocheng/2453.html1.在chrome网上应用商店中搜索：sourcegraph2.找到Sourcegraph for GitHub，点击添加至CHROME。 在GitHub上利用Sourcegraph查看阅读代码进入GitHub，找一个项目，点开一个文件，在工具栏里会看到多了一个View File的按钮，点击此按钮，如下图：进入如下页面： 这样我们就可利用Sourcegraph很方便地查看代码了，是不是很方便，而且项目结构也非常清晰^.^。]]></content>
      <categories>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于windows平台Git+GitHub+Hexo搭建个人博客（三）]]></title>
    <url>%2F2018-08%2Fblog-build-hexo-3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;去年的时候使用Hexo搭建了一个博客，当时主题使用的是JackMan，虽说这个theme是挺好看的了，但是自己感觉还少点东西，所以自从搭建好后就一直没用，笔记还是放在CSDN上。前两天偶然发现了一位大神的博客，当时一眼就喜欢上了这个主题，浏览网站后知道大神的博客也是用Hexo搭建的，内心窃喜。于是乎就去NexT官网clone，又根据自己之前写的博客笔记重新美化了自己的博客，大功告成。 &emsp;&emsp;下面说一下在美化自己博客的时候遇到的问题及解决方法： Q&amp;A遇到的问题needmoreshare2 开启分享功能后使用微信分享无法生成二维码。 问题原因生成二维码的链接失效 解决方法找到资源目录下的needsharebutton.js文件（themes/next/source/lib/needsharebutton/），打开文件，找到该行代码并注释： 1var imgSrc = "https://api.qinco.me/api/qr?size=400&amp;content=" + encodeURIComponent(myoptions.url); 复制下面的代码粘贴到刚注释的代码下方： 1var imgSrc = 'https://api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data='+encodeURIComponent(myoptions.url); 重新运行，就OK了。当然，我现在使用的并不是needmoreshare2，而是Addthis，它可以自定义样式，自我感觉要好看一些。 分享一些搭建博客相关link hexo搭建个人博客详细教程hexo生成博文插入图片hexo设置阅读全文hexo网站统计 博文存储形式及位置修改用hexo new 文章名称 命令创建新文件的时候，会默认存放于博客根目录的source/_posts文件夹下，这样博文少了还好，但是多了就不好维护了。我们可以修改博文存放方式，将博文存放在以yyyy-MM 也就是‘年-月’这种格式的文件夹下，以年-月分类，方便维护。下面具体来说配置方法： 修改博客根目录配置文件_config.yml修改new_post_name 参数找到new_post_name: :title.md 这里配置新建文件的名称，我们将属性值:title.md 修改为:year-:month/:title.md 也就是在文件名称前面加了一个目录，该目录名称的格式是年-月。所以当我们在执行hexo new 文章名称 的时候，会自动在_post文件夹下再创建一个以年-月为格式的文件夹，新创建的markdown 文件在该文件夹下。 你的文件位置： _post/2018-08/title.md 修改permalink 参数找到permalink: :year/:month/:day/:title/ 这是默认的博文访问路径。我们将其属性值修改为:year-:month/:title/。 按照以上步骤更改完后，可以新建一个post试一下。 编辑器推荐写博客当然少不了好用的编辑器啦。 Sublime Text 3快速、好用、高效！ HexoEditorGitHub上一款开源的MarkDown编辑器。可边编辑边预览。 至于具体哪个好用，自己试了才会知道。我倾向于st3，主要是因为它可以open folder，感觉更方便一些^.^。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于windows平台Git+GitHub+Hexo搭建个人博客（二）]]></title>
    <url>%2F2017-09%2Fblog-build-hexo-2%2F</url>
    <content type="text"><![CDATA[博客主题设置&emsp;&emsp;上一篇中我们已经成功搭建了自己的博客并deploy到远程GitHub上，也有很多炫酷的Hexo主题，我们可以将我们自己的博客设置成自己喜欢的主题。在我们本地博客文件夹下，有个名为themes的文件夹，该文件夹就是用来存放各种主题的。Hexo默认的主题是landscape。 修改主题的步骤 从网上把我们喜欢的主题下载下来，放到themes文件夹下; 打开博客根目录下的_config.yml文件，找到theme的配置项， 1theme: landscape &emsp;&emsp;将landscape改为自己所换的主题名称，就OK了。本地测试一下是否修改成功，再deploy到远程。 常用的Hexo命令from http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于windows平台Git+GitHub+Hexo搭建个人博客（一）]]></title>
    <url>%2F2017-09%2Fblog-build-hexo-1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前最开始是了解并搭建的jekyll框架，然后又从网上百度了一下，很多博客都支持Hexo，觉得Hexo更好用一些，也有很多支持jekyll的，自己确实不知道是jekyll和Hexo哪个更好用一些，所以又搭建了一下Hexo的环境。我在这里对我自己的操作步骤进行总结了一下，教程也可以参考Hexo官方文档，写的比较详细。 什么是Hexo？&emsp;&emsp;简单来说， Hexo是一款快速、简易、强大的基于Node.js的静态博客框架，支持Markdown语法。在安装Hexo之前，必须得安装Node.js。 下面就介绍一下搭建的步骤。当然，在此之前，您已经申请了GitHub账号以及本地已经安装了Git。 安装Node.jsnode.js的安装过程可以参考菜鸟教程，步骤很详细。安装完成之后，可以测试一下是否安装成功：打开cmd，输入 1node -v 出现版本信息则证明安装成功。 安装HexoNode安装完成后，就开始安装Hexo。在cmd命令行下，输入 1npm install -g hexo-cli 回车，安装可能会有些慢，请耐心等待。安装成功后，输入 1hexo version 回车，出现版本信息则安装成功。 创建一个博客新建一个文件夹myblog（作为博客项目的名字，可以随便起），我这里建在了E盘。cmd命令进入刚才新建的文件夹下，输入 1hexo init //初始化博客项目 回车，初始化过程中也请耐心等待。初始化完成后，输入 1npm install 回车，myblog文件夹下会生成如下目录： 1hexo generate //生成静态文件,也可输入 hexo g 完成后，输入： 1hexo server //启动本地服务，也可输入 hexo s 默认本地服务的网址为http://localhost:4000/ ，打开浏览器输入网址，如果看到博客首页，则成功。 感觉超级超级炫酷！ 上传至GitHub 登录进入到您自己的GitHub网站首页，新建一个版本库（New Repository） 版本库的名字需是username.github.io的格式，比如我的用户名是zrxJuly,所以我的版本库名称为zrxJuly.github.io。Description是描述您的版本库的信息的，也可以不写。之后直接点击Create repository就OK了，这样，GitHub上的版本库就创建完成。当时我做的时候，在Setting中还设置了githubpages，一直报错，css样式显示不出来，所以先不要在setting中选择主题了。远程库创建告一段落。 下面回到您自己的本地myblog文件夹下，用编辑器打开名为_config.yml的文件，找到deploy配置项，将内容改为： 1234deploy: type: git #注意 : 后边一定要加空格，下同。 repository: git@github.com:username/username.github.io.git branch: master #分支名称 代码块第三行repository的地址来源：您刚创建远程库的地址修改完成后，再修改一个地方，还是在_config.yml文件下，找到URL部分，将url和root如下设置： 12url: https://username.github.io root: / url修改也可参考Hexo的中文文档保存文件并关闭。3. 本地myblog文件夹下，在这里打开GitBash（右键—-&gt;GitBash Here）,输入以下命令回车： 1npm install hexo-deployer-git --save #不执行此命令无法deploy到远程。 运行完后，输入： 1hexo g //重新生成静态文件 回车。基础步骤完成后，将本地创建的博客deploy到远程,发布到GitHub上： 1hexo d #也可写为hexo deploy 完成后，浏览器中输入您刚才设置的url：https://username.github.io 若和本地打开页面一样则成功。&emsp;&emsp;对于大神来说，很快地就会搭完，so easy的。我想说，搭个博客好心酸，不过这样自己一总结感觉好简单，但是中间就是爱出很多问题，比如deploy到远程的时候，本地是没有一点问题的，但是远程css样式就是加载不出来，网上找了很多方法，试了之后，最后终于好了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
